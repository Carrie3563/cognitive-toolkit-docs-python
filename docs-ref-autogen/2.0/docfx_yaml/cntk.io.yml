api_name: []
items:
- _type: module
  children:
  - cntk.io.MinibatchData
  - cntk.io.MinibatchSource
  - cntk.io.MinibatchSourceFromData
  - cntk.io.StreamConfiguration
  - cntk.io.StreamInformation
  - cntk.io.UserMinibatchSource
  module: cntk.io
  name: cntk.io
  summary: ''
  type: Namespace
  uid: cntk.io
- _type: class
  children:
  - cntk.io.Base64ImageDeserializer
  - cntk.io.CTFDeserializer
  - cntk.io.HTKFeatureDeserializer
  - cntk.io.HTKMLFDeserializer
  - cntk.io.ImageDeserializer
  - cntk.io.StreamDef
  - cntk.io.sequence_to_cntk_text_format
  module: cntk.io
  name: cntk.io.Global
  summary: Proxy object to hold module level functions
  type: Class
  uid: cntk.io.Global
- _type: function
  module: cntk.io
  name: cntk.io.Base64ImageDeserializer
  summary: "Configures the image reader that reads base64 encoded images and corresponding\n\
    labels from a file of the form::\n\n    [sequenceId <tab>] <numerical label (0-based\
    \ class id)> <tab> <base64 encoded image>\n\nSimilarly to the ImageDeserializer,\
    \ the sequenceId prefix is optional and can be omitted.\n\n:param filename: file\
    \ name of the input file dataset that contains images\n                 and corresponding\
    \ labels\n:type filename: str\n\n.. seealso:: :cntkwiki:`Base64ImageDeserializer\
    \ options <BrainScript-and-Python---Understanding-and-Extending-Readers#base64imagedeserializer-options>`\n"
  type: Method
  uid: cntk.io.Base64ImageDeserializer
- _type: function
  module: cntk.io
  name: cntk.io.CTFDeserializer
  summary: "Configures the CNTK text-format reader that reads text-based files with\n\
    lines of the form::\n\n    [Sequence_Id] (Sample)+\n\nwhere::\n\n    Sample=|Input_Name\
    \ (Value )*\n\n:param filename: file name containing the text input\n:type filename:\
    \ str\n:param streams: any dictionary-like object that contains a mapping from\
    \ stream\n                names to :class:`StreamDef` objects. Each StreamDef\
    \ object configures\n                an input stream.\n\n.. seealso:: :cntkwiki:`CNTKTextReader\
    \ format <BrainScript-CNTKTextFormat-Reader>`\n"
  type: Method
  uid: cntk.io.CTFDeserializer
- _type: function
  module: cntk.io
  name: cntk.io.HTKFeatureDeserializer
  summary: "Configures the HTK feature reader that reads speech data from scp files.\n\
    \n:param streams: any dictionary-like object that contains a mapping from stream\n\
    \                names to :class:`StreamDef` objects. Each StreamDef object configures\n\
    \                a feature stream.\n"
  type: Method
  uid: cntk.io.HTKFeatureDeserializer
- _type: function
  module: cntk.io
  name: cntk.io.HTKMLFDeserializer
  summary: "Configures an HTK label reader that reads speech HTK format MLF (Master\n\
    Label File)\n\n:param label_mapping_file: path to the label mapping file\n:type\
    \ label_mapping_file: str\n:param streams: any dictionary-like object that contains\
    \ a mapping from stream\n                names to :class:`StreamDef` objects.\
    \ Each StreamDef object configures\n                a label stream.\n:param phoneBoundaries:\
    \ if phone boundaries should be considered (should be set to True for CTC training,\
    \ False otherwise)\n:type phoneBoundaries: bool\n"
  type: Method
  uid: cntk.io.HTKMLFDeserializer
- _type: function
  module: cntk.io
  name: cntk.io.ImageDeserializer
  summary: "Configures the image reader that reads images and corresponding\nlabels\
    \ from a file of the form::\n\n     <full path to image> <tab> <numerical label\
    \ (0-based class id)>\n\nor::\n\n    sequenceId <tab> path <tab> label\n\n:param\
    \ filename: file name of the map file that associates images to\n            \
    \     classes\n:type filename: str\n\n.. seealso:: :cntkwiki:`Image reader definition\
    \ <BrainScript-Image-reader>`\n"
  type: Method
  uid: cntk.io.ImageDeserializer
- _type: class
  children:
  - cntk.io.MinibatchData.as_sequences
  - cntk.io.MinibatchData.data
  - cntk.io.MinibatchData.end_of_sweep
  - cntk.io.MinibatchData.is_sparse
  - cntk.io.MinibatchData.mask
  - cntk.io.MinibatchData.num_samples
  - cntk.io.MinibatchData.num_sequences
  - cntk.io.MinibatchData.shape
  module: cntk.io
  name: cntk.io.MinibatchData
  summary: 'Holds a minibatch of input data. This is never directly created, but

    only returned by :class:`MinibatchSource` instances.

    '
  type: Class
  uid: cntk.io.MinibatchData
- _type: method
  class: cntk.io.MinibatchData
  module: cntk.io
  name: cntk.io.MinibatchData.as_sequences
  summary: 'Convert the value of this minibatch instance to a sequence of NumPy

    arrays that have their masked entries removed.


    :returns: a list of NumPy arrays if dense, otherwise a SciPy CSR array

    '
  type: Method
  uid: cntk.io.MinibatchData.as_sequences
- _type: attribute
  class: cntk.io.MinibatchData
  module: cntk.io
  name: cntk.io.MinibatchData.data
  summary: Retrieves the underlying :class:`~cntk.core.Value` instance.
  type: Property
  uid: cntk.io.MinibatchData.data
- _type: attribute
  class: cntk.io.MinibatchData
  module: cntk.io
  name: cntk.io.MinibatchData.end_of_sweep
  summary: 'Indicates whether the data in this minibatch comes from a sweep end

    or crosses a sweep boundary (and as a result includes data from

    different sweeps).'
  type: Property
  uid: cntk.io.MinibatchData.end_of_sweep
- _type: attribute
  class: cntk.io.MinibatchData
  module: cntk.io
  name: cntk.io.MinibatchData.is_sparse
  summary: Whether the data in this minibatch is sparse.
  type: Property
  uid: cntk.io.MinibatchData.is_sparse
- _type: attribute
  class: cntk.io.MinibatchData
  module: cntk.io
  name: cntk.io.MinibatchData.mask
  summary: 'The mask object of the minibatch. In it, `2` marks the beginning of a

    sequence, `1` marks a sequence element as valid, and `0` marks it as

    invalid.'
  type: Property
  uid: cntk.io.MinibatchData.mask
- _type: attribute
  class: cntk.io.MinibatchData
  module: cntk.io
  name: cntk.io.MinibatchData.num_samples
  summary: The number of samples in this minibatch
  type: Property
  uid: cntk.io.MinibatchData.num_samples
- _type: attribute
  class: cntk.io.MinibatchData
  module: cntk.io
  name: cntk.io.MinibatchData.num_sequences
  summary: The number of sequences in this minibatch
  type: Property
  uid: cntk.io.MinibatchData.num_sequences
- _type: attribute
  class: cntk.io.MinibatchData
  module: cntk.io
  name: cntk.io.MinibatchData.shape
  summary: The shape of the data in this minibatch as tuple.
  type: Property
  uid: cntk.io.MinibatchData.shape
- _type: class
  children:
  - cntk.io.MinibatchSource.current_position
  - cntk.io.MinibatchSource.get_checkpoint_state
  - cntk.io.MinibatchSource.is_distributed
  - cntk.io.MinibatchSource.next_minibatch
  - cntk.io.MinibatchSource.restore_from_checkpoint
  - cntk.io.MinibatchSource.stream_info
  - cntk.io.MinibatchSource.stream_infos
  - cntk.io.MinibatchSource.streams
  module: cntk.io
  name: cntk.io.MinibatchSource
  summary: ":param deserializers: deserializers to be used in the composite reader\n\
    :type deserializers: a single deserializer or a `list`\n:param max_samples: The\
    \ maximum number of input samples\n                    (not 'label samples') the\
    \ reader can produce. After this number has been reached, the reader\n       \
    \             returns empty minibatches on subsequent calls to :meth:`next_minibatch`.\
    \ `max_samples` and `max_sweeps`\n                    are mutually exclusive,\
    \ an exception will be raised if both have non-default values.\n             \
    \       **Important:**\n                    Click :cntkwiki:`here <BrainScript-epochSize-and-Python-epoch_size-in-CNTK>`\n\
    \                    for a description of input and label samples.\n:type max_samples:\
    \ `int`, defaults to :const:`cntk.io.INFINITELY_REPEAT`\n:param max_sweeps: The\
    \ maximum number of of sweeps over\n                   the input dataset After\
    \ this number has been reached, the reader returns empty minibatches on\n    \
    \               subsequent calls to func:`next_minibatch`. `max_samples` and `max_sweeps`\
    \ are mutually exclusive,\n                   an exception will be raised if both\
    \ have non-default values.\n:type max_sweeps: `int`, defaults to :const:`cntk.io.INFINITELY_REPEAT`\n\
    :param randomization_window_in_chunks: size of the randomization window in chunks,\
    \ non-zero value enables randomization.\n                                    \
    \   `randomization_window_in_chunks` and `randomization_window_in_samples` are\
    \ mutually exclusive,\n                                       an exception will\
    \ be raised if both have non-zero values.\n:type randomization_window_in_chunks:\
    \ `int`, defaults to :const:`cntk.io.DEFAULT_RANDOMIZATION_WINDOW_IN_CHUNKS`\n\
    :param randomization_window_in_samples: size of the randomization window in samples,\n\
    \                                        non-zero value enables randomization.\n\
    \                                        `randomization_window_in_chunks` and\
    \ `randomization_window_in_samples` are mutually exclusive,\n                \
    \                        an exception will be raised if both have non-zero values.\n\
    :type randomization_window_in_samples: `int`, defaults to `0`\n:param randomization_seed:\
    \ initial randomization seed value (incremented every sweep when\n           \
    \                the input data is re-randomized).\n:type randomization_seed:\
    \ `int`, defaults to 0\n:param trace_level: the output verbosity level, defaults\
    \ to\n                    the current logging verbosity level given by :func:`~cntk.logging.get_trace_level`.\n\
    :type trace_level: an instance of :class:`cntk.logging.TraceLevel`\n:param multithreaded_deserializer:\
    \ specifies if the deserialization should be\n                               \
    \    done on a single or multiple threads. Defaults to `None`, which is effectively\
    \ \"auto\" (multhithreading\n                                   is disabled unless\
    \ ImageDeserializer is present in the deserializers list). `False` and `True`\n\
    \                                   faithfully turn the multithreading off/on.\n\
    :type multithreaded_deserializer: `bool`\n:param frame_mode: switches the frame\
    \ mode on and off. If the frame mode\n                   is enabled the input\
    \ data will be processed as individual frames ignoring all sequence information\n\
    \                   (this option cannot be used for BPTT, an exception will be\
    \ raised if frame mode is enabled and the\n                   truncation length\
    \ is non-zero).\n:type frame_mode: `bool`, defaults to `False`\n:param truncation_length:\
    \ truncation length in samples, non-zero value enables\n                     \
    \     the truncation (only applicable for BPTT, cannot be used in frame mode,\
    \ an exception will be raised\n                          if frame mode is enabled\
    \ and the truncation length is non-zero).\n:type truncation_length: `int`, defaults\
    \ to `0`\n:param randomize: Enables or disables randomization; use randomization_window_in_chunks\
    \ or\n                  randomization_window_in_samples to specify the randomization\
    \ range\n:type randomize: `bool`, defaults to `True`\n"
  type: Class
  uid: cntk.io.MinibatchSource
- _type: attribute
  class: cntk.io.MinibatchSource
  module: cntk.io
  name: cntk.io.MinibatchSource.current_position
  summary: "Gets current position in the minibatch source.\n\n:param getter: minibatch\
    \ position on the\n               global timeline.\n:type getter: :class:`~cntk.cntk_py.Dictionary`\n\
    :param setter: position returned by\n               the getter\n:type setter:\
    \ :class:`~cntk.cntk_py.Dictionary`"
  type: Property
  uid: cntk.io.MinibatchSource.current_position
- _type: method
  class: cntk.io.MinibatchSource
  module: cntk.io
  name: cntk.io.MinibatchSource.get_checkpoint_state
  summary: "Gets the checkpoint state of the MinibatchSource.\n\n:returns: A :class:`~cntk.cntk_py.Dictionary`\
    \ that has the checkpoint state\n          of the MinibatchSource\n:rtype: cntk.cntk_py.Dictionary\n"
  type: Method
  uid: cntk.io.MinibatchSource.get_checkpoint_state
- _type: attribute
  class: cntk.io.MinibatchSource
  module: cntk.io
  name: cntk.io.MinibatchSource.is_distributed
  summary: Whether the minibatch source is running distributed
  type: Property
  uid: cntk.io.MinibatchSource.is_distributed
- _type: method
  class: cntk.io.MinibatchSource
  module: cntk.io
  name: cntk.io.MinibatchSource.next_minibatch
  summary: "Reads a minibatch that contains data for all input streams.  The\nminibatch\
    \ size is specified in terms of #samples and/or #sequences for\nthe primary input\
    \ stream; value of 0 for #samples/#sequences means\nunspecified.  In case the\
    \ size is specified in terms of both #sequences\nand #samples, the smaller of\
    \ the 2 is taken.  An empty map is returned\nwhen the MinibatchSource has no more\
    \ data to return.\n\n:param minibatch_size_in_samples: number of samples to retrieve\
    \ for\n                                  the next minibatch. Must be > 0.\n  \
    \                                **Important:**\n                            \
    \      Click :cntkwiki:`here <BrainScript-minibatchSize-and-Python-minibatch_size_in_samples-in-CNTK>`\
    \ for a full description of this parameter.\n:type minibatch_size_in_samples:\
    \ int\n:param input_map: mapping of :class:`~cntk.variables.Variable`\n      \
    \            to :class:`StreamInformation` which will be used to convert the\n\
    \                  returned data.\n:type input_map: dict\n:param device: CNTK\
    \ DeviceDescriptor\n:type device: `DeviceDescriptor`, defaults to `None`\n:param\
    \ num_data_partitions: Used for distributed training, indicates into how many\
    \ partitions\n                            the source should split the data.\n\
    :param partition_index: Used for distributed training, indicates data from which\
    \ partition to take.\n:type partition_index: `int`, defaults to `None`\n\n:returns:\
    \  A mapping of :class:`StreamInformation` to :class:`MinibatchData` if\n    \
    \       `input_map` was not specified. Otherwise, the returned value will\n  \
    \         be a mapping of :class:`~cntk.variables.Variable` to class:`MinibatchData`.\n\
    \           When the maximum number of epochs/samples is exhausted, the return\
    \ value is an empty dict.\n:rtype: cntk.io.MinibatchData\n"
  type: Method
  uid: cntk.io.MinibatchSource.next_minibatch
- _type: method
  class: cntk.io.MinibatchSource
  module: cntk.io
  name: cntk.io.MinibatchSource.restore_from_checkpoint
  summary: 'Restores the MinibatchSource state from the specified checkpoint.


    :param checkpoint: checkpoint to restore from

    :type checkpoint: :class:`~cntk.cntk_py.Dictionary`

    '
  type: Method
  uid: cntk.io.MinibatchSource.restore_from_checkpoint
- _type: method
  class: cntk.io.MinibatchSource
  module: cntk.io
  name: cntk.io.MinibatchSource.stream_info
  summary: "Gets the description of the stream with given name.\nThrows an exception\
    \ if there are none or multiple streams with this\nsame name.\n\n:param name:\
    \ stream name to fetch\n:type name: str\n\n:returns: :class:`StreamInformation`\n\
    \          The information for the given stream name.\n"
  type: Method
  uid: cntk.io.MinibatchSource.stream_info
- _type: method
  class: cntk.io.MinibatchSource
  module: cntk.io
  name: cntk.io.MinibatchSource.stream_infos
  summary: 'Describes the streams this minibatch source produces.


    :returns: A list of instances of :class:`StreamInformation`

    '
  type: Method
  uid: cntk.io.MinibatchSource.stream_infos
- _type: attribute
  class: cntk.io.MinibatchSource
  module: cntk.io
  name: cntk.io.MinibatchSource.streams
  summary: "Describes the streams 'this' minibatch source produces.\n\n:returns: A\
    \ `dict` mapping input names to instances of\n          :class:`StreamInformation`"
  type: Property
  uid: cntk.io.MinibatchSource.streams
- _type: class
  children:
  - cntk.io.MinibatchSourceFromData.get_checkpoint_state
  - cntk.io.MinibatchSourceFromData.next_minibatch
  - cntk.io.MinibatchSourceFromData.restore_from_checkpoint
  - cntk.io.MinibatchSourceFromData.stream_infos
  module: cntk.io
  name: cntk.io.MinibatchSourceFromData
  summary: "This wraps in-memory data as a CNTK MinibatchSource object (aka \"reader\"\
    ), used to feed the data into a TrainingSession.\n\nUse this if your data is small\
    \ enough to be loaded into RAM in its entirety, and\nthe data is already sufficiently\
    \ randomized.\n\nWhile CNTK allows user code to iterate through minibatches by\
    \ itself and feed data minibatch\nby minibatch through :func:`~cntk.train.trainer.Trainer.train_minibatch`,\
    \ the standard way is to iterate\nthrough data using a MinibatchSource object.\
    \ For example, the high-level :class:`~cntk.train.training_session.TrainingSession`\n\
    interface, which manages a full training including checkpointing and cross validation,\
    \ operates on this level.\n\nA MinibatchSource created as a `MinibatchSourceFromData`\
    \ linearly iterates through the data provided by\nthe caller as numpy arrays or\
    \ scipy.sparse.csr_matrix objects, without randomization.\nThe data is not copied,\
    \ so if you want to modify the data while being read through a `MinibatchSourceFromData`,\n\
    please pass a copy.\n\n.. admonition:: Example\n\n   >>> N = 5\n   >>> X = np.arange(3*N).reshape(N,3).astype(np.float32)\
    \ # 6 rows of 3 values\n   >>> s = C.io.MinibatchSourceFromData(dict(x=X), max_samples=len(X))\n\
    \   >>> mb = s.next_minibatch(3) # get a minibatch of 3\n   >>> d = mb[s.streams['x']]\n\
    \   >>> d.data.asarray()\n   array([[ 0.,  1.,  2.],\n          [ 3.,  4.,  5.],\n\
    \          [ 6.,  7.,  8.]], dtype=float32)\n   >>> mb = s.next_minibatch(3) #\
    \ note: only 2 left\n   >>> d = mb[s.streams['x']]\n   >>> d.data.asarray()\n\
    \   array([[  9.,  10.,  11.],\n          [ 12.,  13.,  14.]], dtype=float32)\n\
    \   >>> mb = s.next_minibatch(3)\n   >>> mb\n   {}\n   \n   >>> # example of a\
    \ sparse input\n   >>> Y = np.array([i % 3 == 0 for i in range(N)], np.float32)\n\
    \   >>> import scipy.sparse\n   >>> Y = scipy.sparse.csr_matrix((np.ones(N,np.float32),\
    \ (range(N), Y)), shape=(N, 2))\n   >>> s = C.io.MinibatchSourceFromData(dict(x=X,\
    \ y=Y)) # also not setting max_samples -> will repeat\n   >>> mb = s.next_minibatch(3)\n\
    \   >>> d = mb[s.streams['y']]\n   >>> d.data.asarray().todense()\n   matrix([[\
    \ 0.,  1.],\n           [ 1.,  0.],\n           [ 1.,  0.]], dtype=float32)\n\
    \   >>> mb = s.next_minibatch(3) # at end only 2 sequences\n   >>> d = mb[s.streams['y']]\n\
    \   >>> d.data.asarray().todense()\n   matrix([[ 0.,  1.],\n           [ 1., \
    \ 0.]], dtype=float32)\n   \n   >>> # if we do not set max_samples, then it will\
    \ start over once the end is hit\n   >>> mb = s.next_minibatch(3)\n   >>> d =\
    \ mb[s.streams['y']]\n   >>> d.data.asarray().todense()\n   matrix([[ 0.,  1.],\n\
    \           [ 1.,  0.],\n           [ 1.,  0.]], dtype=float32)\n   \n   >>> #\
    \ values can also be GPU-side CNTK Value objects (if everything fits into the\
    \ GPU at once)\n   >>> s = C.io.MinibatchSourceFromData(dict(x=C.Value(X), y=C.Value(Y)))\n\
    \   >>> mb = s.next_minibatch(3)\n   >>> d = mb[s.streams['y']]\n   >>> d.data.asarray().todense()\n\
    \   matrix([[ 0.,  1.],\n           [ 1.,  0.],\n           [ 1.,  0.]], dtype=float32)\n\
    \   \n   >>> # data can be sequences\n   >>> import cntk.layers.typing\n   >>>\
    \ XX = [np.array([1,3,2], np.float32),np.array([4,1], np.float32)]  # 2 sequences\n\
    \   >>> YY = [scipy.sparse.csr_matrix(np.array([[0,1],[1,0],[1,0]], np.float32)),\
    \ scipy.sparse.csr_matrix(np.array([[1,0],[1,0]], np.float32))]\n   >>> s = cntk.io.MinibatchSourceFromData(dict(xx=(XX,\
    \ cntk.layers.typing.Sequence[cntk.layers.typing.tensor]), yy=(YY, cntk.layers.typing.Sequence[cntk.layers.typing.tensor])))\n\
    \   >>> mb = s.next_minibatch(3)\n   >>> mb[s.streams['xx']].data.asarray()\n\
    \   array([[ 1.,  3.,  2.]], dtype=float32)\n   >>> mb[s.streams['yy']].data.shape\
    \ # getting sequences out is messy, so we only show the shape\n   (1, 3, 2)\n\n\
    :param data_streams: name-value pairs\n:param max_samples: The maximum number\
    \ of samples\n                    the reader can produce. If inputs are sequences,\
    \ and the different streams have different\n                    lengths, then\
    \ each sequence counts with the the maximum length.\n                    After\
    \ this number has been reached, the reader\n                    returns empty\
    \ minibatches on subsequent calls to :meth:`next_minibatch`.\n               \
    \     **Important:**\n                    Click :cntkwiki:`here <BrainScript-epochSize-and-Python-epoch_size-in-CNTK>`\n\
    \                    for a description of input and label samples.\n:type max_samples:\
    \ `int`, defaults to :const:`cntk.io.INFINITELY_REPEAT`\n\n:returns: An implementation\
    \ of a :class:`cntk.io.MinibatchSource` that will iterate through the data.\n"
  type: Class
  uid: cntk.io.MinibatchSourceFromData
- _type: method
  class: cntk.io.MinibatchSourceFromData
  module: cntk.io
  name: cntk.io.MinibatchSourceFromData.get_checkpoint_state
  summary: "Gets the checkpoint state of the MinibatchSource.\n\n:returns: A :class:`~cntk.cntk_py.Dictionary`\
    \ that has the checkpoint state\n          of the MinibatchSource\n:rtype: cntk.cntk_py.Dictionary\n"
  type: Method
  uid: cntk.io.MinibatchSourceFromData.get_checkpoint_state
- _type: method
  class: cntk.io.MinibatchSourceFromData
  module: cntk.io
  name: cntk.io.MinibatchSourceFromData.next_minibatch
  summary: ''
  type: Method
  uid: cntk.io.MinibatchSourceFromData.next_minibatch
- _type: method
  class: cntk.io.MinibatchSourceFromData
  module: cntk.io
  name: cntk.io.MinibatchSourceFromData.restore_from_checkpoint
  summary: 'Restores the MinibatchSource state from the specified checkpoint.


    :param checkpoint: checkpoint to restore from

    :type checkpoint: :class:`~cntk.cntk_py.Dictionary`

    '
  type: Method
  uid: cntk.io.MinibatchSourceFromData.restore_from_checkpoint
- _type: method
  class: cntk.io.MinibatchSourceFromData
  module: cntk.io
  name: cntk.io.MinibatchSourceFromData.stream_infos
  summary: ''
  type: Method
  uid: cntk.io.MinibatchSourceFromData.stream_infos
- _type: class
  children: []
  module: cntk.io
  name: cntk.io.StreamConfiguration
  summary: "Configuration of a stream in a text format reader.\n\n:param name: name\
    \ of this stream\n:type name: str\n:param dim: dimensions of this stream. A text\
    \ format reader reads data\n            as flat arrays. If you need different\
    \ shapes you can\n            :func:`~cntk.ops.reshape` it later.\n:type dim:\
    \ int\n:param is_sparse: whether the provided data is\n                  sparse\
    \ (`False` by default)\n:type is_sparse: bool, defaults to `False`\n:param stream_alias:\
    \ name of the stream in the file\n:type stream_alias: str, defaults to ''\n:param\
    \ defines_mb_size: whether this stream defines\n                        the minibatch\
    \ size.\n:type defines_mb_size: `bool`, defaults to False\n"
  type: Class
  uid: cntk.io.StreamConfiguration
- _type: function
  module: cntk.io
  name: cntk.io.StreamDef
  summary: "   Configuration of a stream for use with the builtin Deserializers.\n\
    \   The meanings of some configuration keys have a mild dependency on the\n  \
    \ exact deserializer, and certain keys are meaningless for certain\n   deserializers.\n\
    \n:param field: this is the name of the stream\n\n              * for CTFDeserializer\
    \ the name is inside the CTF file\n              * for ImageDeserializer the acceptable\
    \ names are `image` or `label`\n              * for HTKFeatureDeserializer and\
    \ HTKMLFDeserializer only the default\n                value of None is acceptable\n\
    :type field: `str`, defaults to `None`\n:param shape: dimensions of this\n   \
    \           stream. HTKFeatureDeserializer, HTKMLFDeserializer, and\n        \
    \      CTFDeserializer read data as flat arrays. If you need different\n     \
    \         shapes you can :func:`~cntk.ops.reshape` it later.\n:type shape: `int`\
    \ or `tuple`, defaults to `None`\n:param is_sparse: whether the provided data\
    \ is\n                  sparse. `False` by default, unless mlf is provided.\n\
    :type is_sparse: `bool`, defaults to `False`\n:param transforms: list of transforms\
    \ to be\n                   applied by the Deserializer. Currently only ImageDeserializer\n\
    \                   supports transforms.\n:type transforms: `list`, defaults to\
    \ `None`\n:param context: left and right context to\n                consider\
    \ when reading in HTK data. Only supported by\n                HTKFeatureDeserializer.\n\
    :type context: `tuple`, defaults to `None`\n:param scp: scp files for HTK data\n\
    :type scp: `str` or `list`, defaults to `None`\n:param mlf: mlf files for HTK\
    \ data\n:type mlf: `str` or `list`, defaults to `None`\n:param broadcast: whether\
    \ the features in this\n                  stream should be broadcast to the whole\
    \ sequence (useful in e.g.\n                  ivectors with HTK)\n:type broadcast:\
    \ `bool`, defaults to `None`\n:param defines_mb_size: whether this stream defines\n\
    \                        the minibatch size.\n:type defines_mb_size: `bool`, defaults\
    \ to False\n"
  type: Method
  uid: cntk.io.StreamDef
- _type: class
  children: []
  module: cntk.io
  name: cntk.io.StreamInformation
  summary: 'Stream information container that is used to describe streams when

    implementing custom minibatch source through :class:`UserMinibatchSource`.


    :param name: name of the stream

    :type name: str

    :param stream_id: unique ID of the stream

    :type stream_id: int

    :param storage_format: ''dense'' or ''sparse''

    :type storage_format: str

    :param dtype: data type

    :type dtype: NumPy type

    :param shape: shape of the elements

    :type shape: tuple

    '
  type: Class
  uid: cntk.io.StreamInformation
- _type: class
  children:
  - cntk.io.UserMinibatchSource.get_checkpoint_state
  - cntk.io.UserMinibatchSource.next_minibatch
  - cntk.io.UserMinibatchSource.restore_from_checkpoint
  - cntk.io.UserMinibatchSource.stream_info
  - cntk.io.UserMinibatchSource.stream_infos
  module: cntk.io
  name: cntk.io.UserMinibatchSource
  summary: 'Base class of all user minibatch sources.

    '
  type: Class
  uid: cntk.io.UserMinibatchSource
- _type: method
  class: cntk.io.UserMinibatchSource
  module: cntk.io
  name: cntk.io.UserMinibatchSource.get_checkpoint_state
  summary: 'Returns a dictionary describing the current state of the minibatch

    source. Needs to be overwritten if the state of the minibatch source

    needs to be stored to and later restored from the checkpoint.


    :returns: dictionary, that can be later used on :meth:`restore_from_checkpoint`.

    '
  type: Method
  uid: cntk.io.UserMinibatchSource.get_checkpoint_state
- _type: method
  class: cntk.io.UserMinibatchSource
  module: cntk.io
  name: cntk.io.UserMinibatchSource.next_minibatch
  summary: 'Function to be implemented by the user.


    :param num_samples: number of samples to return

    :type num_samples: int

    :param number_of_workers: number of workers in total

    :type number_of_workers: int

    :param worker_rank: worker for which the data is to be returned

    :type worker_rank: int


    :returns: mapping of :class:`StreamInformation` to :class:`MinibatchData`

    '
  type: Method
  uid: cntk.io.UserMinibatchSource.next_minibatch
- _type: method
  class: cntk.io.UserMinibatchSource
  module: cntk.io
  name: cntk.io.UserMinibatchSource.restore_from_checkpoint
  summary: 'Sets the state of the checkpoint.


    :param state: dictionary containing the state

    :type state: dict

    '
  type: Method
  uid: cntk.io.UserMinibatchSource.restore_from_checkpoint
- _type: method
  class: cntk.io.UserMinibatchSource
  module: cntk.io
  name: cntk.io.UserMinibatchSource.stream_info
  summary: 'Gets the description of the stream with given name.

    Throws an exception if there are none or multiple streams with this

    same name.

    '
  type: Method
  uid: cntk.io.UserMinibatchSource.stream_info
- _type: method
  class: cntk.io.UserMinibatchSource
  module: cntk.io
  name: cntk.io.UserMinibatchSource.stream_infos
  summary: 'Function to be implemented by the user.


    :returns: list of :class:`StreamInformation` instances

    '
  type: Method
  uid: cntk.io.UserMinibatchSource.stream_infos
- _type: function
  module: cntk.io
  name: cntk.io.sequence_to_cntk_text_format
  summary: "Converts a list of NumPy arrays representing tensors of inputs into a\n\
    format that is readable by :class:`~cntk.io.CTFDeserializer`.\n\n:param seq_idx:\
    \ number of current sequence\n:type seq_idx: int\n:param alias_tensor_map: maps\
    \ alias (str) to tensor (ndarray). Tensors\n                         are assumed\
    \ to have dynamic axis.\n:type alias_tensor_map: dict\n\n:returns: String representation\
    \ in :cntkwiki:`CNTKTextReader format <BrainScript-CNTKTextFormat-Reader>`\n:rtype:\
    \ str\n"
  type: Method
  uid: cntk.io.sequence_to_cntk_text_format
