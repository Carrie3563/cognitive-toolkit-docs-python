api_name: []
items:
- _type: module
  children: []
  module: cntk.ops.sequence
  name: cntk.ops.sequence
  summary: ''
  type: Namespace
  uid: cntk.ops.sequence
- _type: class
  children:
  - cntk.ops.sequence.broadcast_as
  - cntk.ops.sequence.delay
  - cntk.ops.sequence.first
  - cntk.ops.sequence.future_value
  - cntk.ops.sequence.gather
  - cntk.ops.sequence.input
  - cntk.ops.sequence.input_variable
  - cntk.ops.sequence.is_first
  - cntk.ops.sequence.is_last
  - cntk.ops.sequence.last
  - cntk.ops.sequence.past_value
  - cntk.ops.sequence.reduce_max
  - cntk.ops.sequence.reduce_sum
  - cntk.ops.sequence.scatter
  - cntk.ops.sequence.slice
  - cntk.ops.sequence.softmax
  - cntk.ops.sequence.unpack
  - cntk.ops.sequence.where
  module: cntk.ops.sequence
  name: cntk.ops.sequence.Global
  summary: Proxy object to hold module level functions
  type: Class
  uid: cntk.ops.sequence.Global
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.broadcast_as
  summary: "Creates a sequence out of a non-sequence by endowing the ``operand``\n\
    with dynamic axes of the same type as the ``broadcast_as_operand``\nand broadcasting\
    \ the value of the ``operand`` along those dynamic axes.\n\n.. admonition:: Example\n\
    \n   >>> x = C.sequence.input_variable(shape=(3,2))\n   >>> t = C.sequence.last(x)\n\
    \   >>> b = C.sequence.is_first(x)\n   >>> y = C.sequence.broadcast_as(t, b)\n\
    \   >>> # create one sequence of 4 tensors each with shape (3,2)\n   >>> x0 =\
    \ np.reshape(np.arange(24.0,dtype=np.float32),(1,4,3,2))\n   >>> y.eval({x:x0})\n\
    \   [array([[[ 18.,  19.],\n            [ 20.,  21.],\n            [ 22.,  23.]],\n\
    \   <BLANKLINE>\n           [[ 18.,  19.],\n            [ 20.,  21.],\n      \
    \      [ 22.,  23.]],\n   <BLANKLINE>\n           [[ 18.,  19.],\n           \
    \ [ 20.,  21.],\n            [ 22.,  23.]],\n   <BLANKLINE>\n           [[ 18.,\
    \  19.],\n            [ 20.,  21.],\n            [ 22.,  23.]]], dtype=float32)]\n\
    \n:param operand: the symbolic tensor whose value will be broadcast\n:param broadcast_as_operand:\
    \ the symbolic tensor whose dynamic axes will\n                             be\
    \ used to broadcast the operand\n:param name: the name of the node in the network\n\
    :type name: str\n\n:returns: :class:`~cntk.ops.functions.Function`\n"
  type: Method
  uid: cntk.ops.sequence.broadcast_as
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.delay
  summary: 'This function combines :func:`~cntk.ops.sequence.past_value` and :func:`~cntk.ops.sequence.future_value`
    into a single function.

    This is useful when the time_step is computed and can be positive, negative, or
    0.


    :param x: the tensor (or its name) from which the past value is obtained

    :param initial_state: tensor or scalar representing the initial value to be used
    when the input tensor is shifted in time.

    :param time_step: the number of time steps to look into the past, where negative
    values mean to look into the future, and 0 means a no-op (default 1).

    :type time_step: int

    :param name: the name of the Function instance in the network

    :type name: str, optional

    '
  type: Method
  uid: cntk.ops.sequence.delay
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.first
  summary: "Returns the first element of its symbolic input sequence ``seq``\n\n..\
    \ admonition:: Example\n\n   >>> x = C.sequence.input_variable(shape=(3,2))\n\
    \   >>> y = C.sequence.first(x)\n   >>> # create one sequence of 4 tensors each\
    \ with shape (3,2)\n   >>> x0 = np.reshape(np.arange(24.0,dtype=np.float32),(1,4,3,2))\n\
    \   >>> y.eval({x:x0})\n   array([[[ 0.,  1.],\n            [ 2.,  3.],\n    \
    \        [ 4.,  5.]]], dtype=float32)\n\n:param seq: the symbolic tensor denoting\
    \ a sequence\n:param name: the name of the node in the network\n:type name: str\n\
    \n:returns: :class:`~cntk.ops.functions.Function`\n"
  type: Method
  uid: cntk.ops.sequence.first
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.future_value
  summary: "This function returns the future value w.r.t. ``x``. It is most often\
    \ used when\ncreating RNNs. The resulting tensor has the same shape as the input\
    \ but is\nthe next logical sample. The ``time_step`` parameter is the number of\
    \ steps\nto look into the future and is 1 by default. If there is no future value\
    \ (i.e.\nthe current sample is the last one in the tensor) then the ``initial_state``\n\
    value is returned.\n\nThe initial state can be a constant (scalar or tensor),\
    \ a learnable tensor\nor input data (which has a batch dimension, as needed for\
    \ sequence-to-sequence models).\n\n.. admonition:: Example\n\n   >>> x = C.sequence.input_variable(shape=(3,2))\n\
    \   >>> # Create one sequence with 4 tensors of shape (3, 2)\n   >>> x0 = np.reshape(np.arange(24,dtype=np.float32),(1,4,3,2))\n\
    \   >>> y = C.sequence.future_value(x) # using initial state of 0 by default\n\
    \   >>> y.eval({x:x0})\n   [array([[[  6.,   7.],\n            [  8.,   9.],\n\
    \            [ 10.,  11.]],\n   <BLANKLINE>\n           [[ 12.,  13.],\n     \
    \       [ 14.,  15.],\n            [ 16.,  17.]],\n   <BLANKLINE>\n          \
    \ [[ 18.,  19.],\n            [ 20.,  21.],\n            [ 22.,  23.]],\n   <BLANKLINE>\n\
    \           [[  0.,   0.],\n            [  0.,   0.],\n            [  0.,   0.]]],\
    \ dtype=float32)]\n\n:param x: the tensor (or its name) from which the future\
    \ value is obtained.\n:param initial_state: tensor or scalar representing the\
    \ initial value to be used when the input tensor is shifted in time.\n:param time_step:\
    \ the number of time steps to look into the future (default 1)\n:type time_step:\
    \ int\n:param name: the name of the Function instance in the network\n:type name:\
    \ str, optional\n\n:returns: :class:`~cntk.ops.functions.Function`\n"
  type: Method
  uid: cntk.ops.sequence.future_value
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.gather
  summary: "Takes two sequences of the same length and returns a new sequence whose\n\
    elements are those elements of sequence ``seq`` whose corresponding element\n\
    in ``condition`` is True, preserving the ordering of ``seq``.\n\nThis operation\
    \ is also known as stream compaction, or copy_if.\n\n.. admonition:: Example\n\
    \n   >>> x = C.sequence.input_variable(shape=(3,2))\n   >>> z = C.greater(C.reduce_sum(x),60)\n\
    \   >>> y = C.sequence.gather(x,z)\n   >>> # create one sequence of 4 tensors\
    \ each with shape (3,2)\n   >>> x0 = np.reshape(np.arange(24.0,dtype=np.float32),(1,4,3,2))\n\
    \   >>> y.eval({x:x0})\n   [array([[[ 12.,  13.],\n            [ 14.,  15.],\n\
    \            [ 16.,  17.]],\n   <BLANKLINE>\n           [[ 18.,  19.],\n     \
    \       [ 20.,  21.],\n            [ 22.,  23.]]], dtype=float32)]\n\n:param seq:\
    \ the symbolic sequence from which elements will be selected\n:param condition:\
    \ the symbolic sequence of booleans which indicate which\n                  elements\
    \ should be selected\n:param new_sequence_axis_typeinfo: tuple of integers indicating\n\
    \                                   the scaling and additive factors for the length\
    \ of the new sequence axis\n                                   w.r.t. the operand\
    \ sequence. This is used to determine the sequence axis\n                    \
    \               to be used for the output of the gather operation. If this argument\
    \ is left\n                                   unspecified, a new independent sequence\
    \ axis is created.\n:param name: the name of the node in the network\n:type name:\
    \ str\n\n:returns: :class:`~cntk.ops.functions.Function`\n"
  type: Method
  uid: cntk.ops.sequence.gather
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.input
  summary: 'DEPRECATED.


    It creates an input in the network: a place where data,

    such as features and labels, should be provided.


    :param shape: the shape of the input tensor

    :type shape: tuple or int

    :param dtype: data type. Default is np.float32.

    :type dtype: np.float32 or np.float64

    :param needs_gradients: whether to back-propagates to it or not. False by default.

    :type needs_gradients: bool, optional

    :param is_sparse: whether the variable is sparse (`False` by default)

    :type is_sparse: bool, optional

    :param sequence_axis: a dynamic axis (e.g., default_dynamic_axis())

    :type sequence_axis: :class:`~cntk.axis.Axis`

    :param name: the name of the Function instance in the network

    :type name: str, optional


    :returns: :class:`~cntk.variables.Variable`

    '
  type: Method
  uid: cntk.ops.sequence.input
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.input_variable
  summary: 'It creates an input in the network: a place where data,

    such as features and labels, should be provided.


    :param shape: the shape of the input tensor

    :type shape: tuple or int

    :param dtype: data type. Default is np.float32.

    :type dtype: np.float32 or np.float64

    :param needs_gradients: whether to back-propagates to it or not. False by default.

    :type needs_gradients: bool, optional

    :param is_sparse: whether the variable is sparse (`False` by default)

    :type is_sparse: bool, optional

    :param sequence_axis: a dynamic axis (e.g., default_dynamic_axis())

    :type sequence_axis: :class:`~cntk.axis.Axis`

    :param name: the name of the Function instance in the network

    :type name: str, optional


    :returns: :class:`~cntk.variables.Variable`

    '
  type: Method
  uid: cntk.ops.sequence.input_variable
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.is_first
  summary: "Returns a symbolic sequence of booleans with the same length as ``seq``.\
    \ The\nfirst element of the sequence is 1 and all others are 0.\n\n.. admonition::\
    \ Example\n\n   >>> x = C.sequence.input_variable(shape=(3,2))\n   >>> y = C.sequence.is_first(x)\n\
    \   >>> # create one sequence of 4 tensors each with shape (3,2)\n   >>> x0 =\
    \ np.reshape(np.arange(24.0,dtype=np.float32),(1,4,3,2))\n   >>> y.eval({x:x0})\n\
    \   [array([ 1.,  0.,  0.,  0.], dtype=float32)]\n\n:param seq: the symbolic tensor\
    \ denoting a sequence\n:param name: the name of the node in the network\n:type\
    \ name: str\n\n:returns: :class:`~cntk.ops.functions.Function`\n"
  type: Method
  uid: cntk.ops.sequence.is_first
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.is_last
  summary: "Returns a symbolic sequence of booleans with the same length as ``seq``.\
    \ The\nlast element of the sequence is 1 and all others are 0.\n\n.. admonition::\
    \ Example\n\n   >>> x = C.sequence.input_variable(shape=(3,2))\n   >>> y = C.sequence.is_last(x)\n\
    \   >>> # create one sequence of 4 tensors each with shape (3,2)\n   >>> x0 =\
    \ np.reshape(np.arange(24.0,dtype=np.float32),(1,4,3,2))\n   >>> y.eval({x:x0})\n\
    \   [array([ 0.,  0.,  0.,  1.], dtype=float32)]\n\n:param seq: the symbolic tensor\
    \ denoting a sequence\n:param name: the name of the node in the network\n:type\
    \ name: str\n\n:returns: :class:`~cntk.ops.functions.Function`\n"
  type: Method
  uid: cntk.ops.sequence.is_last
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.last
  summary: "Returns the last element of its symbolic input sequence ``seq``\n\n..\
    \ admonition:: Example\n\n   >>> x = C.sequence.input_variable(shape=(3,2))\n\
    \   >>> y = C.sequence.last(x)\n   >>> # create one sequence of 4 tensors each\
    \ with shape (3,2)\n   >>> x0 = np.reshape(np.arange(24.0,dtype=np.float32),(1,4,3,2))\n\
    \   >>> y.eval({x:x0})\n   array([[[ 18.,  19.],\n            [ 20.,  21.],\n\
    \            [ 22.,  23.]]], dtype=float32)\n\n:param seq: the symbolic tensor\
    \ denoting a sequence\n:param name: the name of the node in the network\n:type\
    \ name: str\n\n:returns: :class:`~cntk.ops.functions.Function`\n"
  type: Method
  uid: cntk.ops.sequence.last
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.past_value
  summary: "This function returns the past value w.r.t. ``x``. It is most often used\
    \ when\ncreating RNNs. The resulting tensor has the same shape as the input but\
    \ is\nthe previous logical sample. The ``time_step`` parameter is the number of\
    \ steps\nto look into the past and is 1 by default. If there is no past value\
    \ (i.e.\nthe current sample is the first one in the tensor)  then the ``initial_state``\n\
    value is returned.\n\nThe initial state can be a constant (scalar or tensor),\
    \ a learnable tensor\nor input data (which has a batch dimension, as needed for\
    \ sequence-to-sequence models).\n\n.. admonition:: Example\n\n   >>> # create\
    \ example input: one sequence with 4 tensors of shape (3, 2)\n   >>> from cntk.layers.typing\
    \ import Tensor, Sequence\n   >>> x = C.sequence.input_variable((3,2))\n   >>>\
    \ x0 = np.reshape(np.arange(24,dtype=np.float32),(1,4,3,2))\n   >>> x0\n   array([[[[\
    \  0.,   1.],\n            [  2.,   3.],\n            [  4.,   5.]],\n   <BLANKLINE>\n\
    \           [[  6.,   7.],\n            [  8.,   9.],\n            [ 10.,  11.]],\n\
    \   <BLANKLINE>\n           [[ 12.,  13.],\n            [ 14.,  15.],\n      \
    \      [ 16.,  17.]],\n   <BLANKLINE>\n           [[ 18.,  19.],\n           \
    \ [ 20.,  21.],\n            [ 22.,  23.]]]], dtype=float32)\n   \n   >>> # this\
    \ demonstrates how past_value shifts the sequence by one, padding with initial_state\n\
    \   >>> y = C.sequence.past_value(x) # initial_state is 0 by default\n   >>> y.eval({x:x0})\n\
    \   [array([[[  0.,   0.],\n            [  0.,   0.],\n            [  0.,   0.]],\n\
    \   <BLANKLINE>\n           [[  0.,   1.],\n            [  2.,   3.],\n      \
    \      [  4.,   5.]],\n   <BLANKLINE>\n           [[  6.,   7.],\n           \
    \ [  8.,   9.],\n            [ 10.,  11.]],\n   <BLANKLINE>\n           [[ 12.,\
    \  13.],\n            [ 14.,  15.],\n            [ 16.,  17.]]], dtype=float32)]\n\
    \   \n   >>> # here, we pass a the initial_state as input data (e.g. sequence-to-sequence)\n\
    \   >>> s = C.input_variable((3,2))  # not a sequence, e.g. a final encoder hidden\
    \ state\n   >>> s0 = np.reshape(np.arange(6,dtype=np.float32)/2,(1,3,2))\n   >>>\
    \ s0\n   array([[[ 0. ,  0.5],\n           [ 1. ,  1.5],\n           [ 2. ,  2.5]]],\
    \ dtype=float32)\n   >>> y = C.sequence.past_value(x, initial_state=s)\n   >>>\
    \ y.eval({x:x0, s:s0}) # same as the previous example except for the first time\
    \ step\n   [array([[[  0. ,   0.5],\n            [  1. ,   1.5],\n           \
    \ [  2. ,   2.5]],\n   <BLANKLINE>\n           [[  0. ,   1. ],\n            [\
    \  2. ,   3. ],\n            [  4. ,   5. ]],\n   <BLANKLINE>\n           [[ \
    \ 6. ,   7. ],\n            [  8. ,   9. ],\n            [ 10. ,  11. ]],\n  \
    \ <BLANKLINE>\n           [[ 12. ,  13. ],\n            [ 14. ,  15. ],\n    \
    \        [ 16. ,  17. ]]], dtype=float32)]\n\n:param x: the tensor (or its name)\
    \ from which the past value is obtained\n:param initial_state: tensor or scalar\
    \ representing the initial value to be used when the input tensor is shifted in\
    \ time.\n:param time_step: the number of time steps to look into the past (default\
    \ 1)\n:type time_step: int\n:param name: the name of the Function instance in\
    \ the network\n:type name: str, optional\n\n:returns: :class:`~cntk.ops.functions.Function`\n"
  type: Method
  uid: cntk.ops.sequence.past_value
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.reduce_max
  summary: 'Computes the max of the input sequence''s elements across the sequence
    axis.


    :param seq: sequence input tensor

    :param name: the name of the Function instance in the network

    :type name: `str`, optional


    :returns: :class:`~cntk.ops.functions.Function`

    '
  type: Method
  uid: cntk.ops.sequence.reduce_max
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.reduce_sum
  summary: "Computes the sum of the input sequence's elements across the sequence\
    \ axis.\n\n.. admonition:: Examples\n\n   >>> x = C.sequence.input_variable(shape=(3,2))\n\
    \   >>> # create one sequence of 4 tensors each with shape (3,2)\n   >>> x0 =\
    \ np.reshape(np.arange(24.0,dtype=np.float32),(1,4,3,2))\n   >>> y = C.sequence.reduce_sum(x)\n\
    \   >>> y.eval({x:x0})\n   array([[[ 36.,  40.],\n            [ 44.,  48.],\n\
    \            [ 52.,  56.]]], dtype=float32)\n\n:param seq: sequence input tensor\n\
    :param name: the name of the Function instance in the network\n:type name: `str`,\
    \ optional\n\n:returns: :class:`~cntk.ops.functions.Function`\n"
  type: Method
  uid: cntk.ops.sequence.reduce_sum
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.scatter
  summary: "Performs the inverse of gather. The sequence ``seq`` must have as many\n\
    elements as the number of True values in the sequence ``condition``.\nIt will\
    \ return a sequence whose length is the same as the ``condition``\nsequence with\
    \ zeroes everywhere except for the locations where ``condition``\nevaluates to\
    \ True in which case it will copy the elements from ``seq``\npreserving their\
    \ order.\n\n.. admonition:: Example\n\n   >>> x = C.sequence.input_variable(shape=(3,2))\n\
    \   >>> t = C.sequence.last(x)\n   >>> b = C.sequence.is_first(x)\n   >>> y =\
    \ C.sequence.scatter(t, b)\n   >>> # create one sequence of 4 tensors each with\
    \ shape (3,2)\n   >>> x0 = np.reshape(np.arange(24.0,dtype=np.float32),(1,4,3,2))\n\
    \   >>> y.eval({x:x0})\n   [array([[[ 18.,  19.],\n            [ 20.,  21.],\n\
    \            [ 22.,  23.]],\n   <BLANKLINE>\n           [[  0.,   0.],\n     \
    \       [  0.,   0.],\n            [  0.,   0.]],\n   <BLANKLINE>\n          \
    \ [[  0.,   0.],\n            [  0.,   0.],\n            [  0.,   0.]],\n   <BLANKLINE>\n\
    \           [[  0.,   0.],\n            [  0.,   0.],\n            [  0.,   0.]]],\
    \ dtype=float32)]\n\n:param seq: the symbolic sequence from which elements will\
    \ be copied in the\n            output\n:param condition: the symbolic sequence\
    \ which denotes the locations where\n                  elements should be copied\n\
    :param new_sequence_axis_typeinfo: tuple of integers indicating\n            \
    \                       the scaling and additive factors for the length of the\
    \ new sequence axis\n                                   w.r.t. the condition sequence.\
    \ This is used to determine the sequence axis\n                              \
    \     to be used for the output of the gather operation. If this argument is left\n\
    \                                   unspecified a new independent sequence axis\
    \ is created.\n:param name: the name of the node in the network\n:type name: str\n\
    \n:returns: :class:`~cntk.ops.functions.Function`\n"
  type: Method
  uid: cntk.ops.sequence.scatter
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.slice
  summary: 'Slice the input sequence.


    :param seq: sequence input tensor

    :param begin_index: the index along sequence axis where the slicing starts

    :type begin_index: `int`

    :param end_index: the index along sequence axis where the slicing ends

    :type end_index: `int`

    :param name: the name of the Function instance in the network

    :type name: `str`, optional


    .. seealso:: Indexing in NumPy: https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html


    :returns: :class:`~cntk.ops.functions.Function`


    .. todo:: add an example

    '
  type: Method
  uid: cntk.ops.sequence.slice
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.softmax
  summary: 'Computes the softmax of the input across the sequence axis.


    :param seq: sequence input tensor

    :param name: the name of the Function instance in the network

    :type name: `str`, optional


    :returns: :class:`~cntk.ops.functions.Function`

    '
  type: Method
  uid: cntk.ops.sequence.softmax
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.unpack
  summary: "This function unpacks the specified sequence operand 'x' along the most\n\
    significant static axis [-1] and pads any gaps with the specified 'padding_value'.\n\
    If the 'no_mask_output' argument is False, the returned Function has 2 outputs;\n\
    viz. the unpacked non-sequence data and a mask denoting the gaps in the unpacked\
    \ output\ndue to differences across lengths of the sequences in the operand.\n\
    \n:param x: the sequence tensor (or its name) which is unpacked\n:param padding_value:\
    \ The value to pad gaps in the unpacked tensor with.\n:type padding_value: np.float32\
    \ or np.float64\n:param no_mask_output: whether the Function has a mask tensor\
    \ output denoting the\n                       gaps in the unpacked output due\
    \ to differences across lengths of the sequences in the operand.\n:type no_mask_output:\
    \ bool, optional\n:param name: the name of the Function instance in the network\n\
    :type name: str, optional\n\n:returns: :class:`~cntk.ops.functions.Function`\n\
    \n.. todo:: add an example\n"
  type: Method
  uid: cntk.ops.sequence.unpack
- _type: function
  module: cntk.ops.sequence
  name: cntk.ops.sequence.where
  summary: "Given a symbolic sequence ``condition`` of boolean-like (1/0) values,\
    \ it will return\na new sequence containing the indices for which the values were\
    \ true.\n\nIf ``condition`` has a value other than 0 or 1, it will denote a repeat\
    \ factor.\nIf a repeat factor is fractional, it will round up but deduct the overshoot\
    \ from the\nnext repeat factor.\n\n.. admonition:: Example\n\n   >>> x = C.sequence.input_variable(shape=(3,2))\n\
    \   >>> z = C.greater(C.reduce_sum(x), 60)\n   >>> # create one sequence of 4\
    \ tensors each with shape (3,2)\n   >>> x0 = np.reshape(np.arange(24.0, dtype=np.float32),\
    \ (1,4,3,2))\n   >>> z.eval({x:x0})\n   [array([ 0.,  0.,  1.,  1.], dtype=float32)]\n\
    \   >>> y = C.sequence.where(z)\n   >>> y.eval({x:x0})\n   [array([ 2.,  3.],\
    \ dtype=float32)]\n   \n   >>> # repeat frame[1] twice, frame[3] three times,\
    \ and frame[4] twice\n   >>> C.sequence.where(C.sequence.input_variable(1)).eval([[[1],\
    \ [2], [1], [3], [2]]])\n   [array([ 0.,  1.,  1.,  2.,  3.,  3.,  3.,  4.,  4.],\
    \ dtype=float32)]\n   >>> # note that the above are the indices that are passed\
    \ to\n   \n   >>> # repeat frames with a fractional factor\n   >>> C.sequence.where(C.sequence.input_variable(1)).eval([[[1.2]]*10])\n\
    \   [array([ 0.,  0.,  1.,  2.,  3.,  4.,  5.,  5.,  6.,  7.,  8.,  9.],\n   \
    \    dtype=float32)]\n   >>> # as a result, a 1.2 times stretch is realized by\
    \ duplicating frame[0] and frame[5]\n\n:param condition: sequence of 0 or 1 values\
    \ for filtering, or other positive values for repetition (also fractional)\n:param\
    \ name: the name of the node in the network\n:type name: str\n\n:returns: :class:`~cntk.ops.functions.Function`\n"
  type: Method
  uid: cntk.ops.sequence.where
